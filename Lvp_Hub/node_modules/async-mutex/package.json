{
  "_from": "async-mutex",
  "_id": "async-mutex@0.2.4",
  "_inBundle": false,
  "_integrity": "sha512-fcQKOXUKMQc57JlmjBCHtkKNrfGpHyR7vu18RfuLfeTAf4hK9PgOadPR5cDrBQ682zasrLUhJFe7EKAHJOduDg==",
  "_location": "/async-mutex",
  "_phantomChildren": {},
  "_requested": {
    "escapedName": "async-mutex",
    "fetchSpec": "latest",
    "name": "async-mutex",
    "raw": "async-mutex",
    "rawSpec": "",
    "registry": true,
    "saveSpec": null,
    "type": "tag"
  },
  "_requiredBy": [
    "#USER",
    "/"
  ],
  "_resolved": "https://registry.npmjs.org/async-mutex/-/async-mutex-0.2.4.tgz",
  "_shasum": "f6ea5f9cc73147f395f86fa573a2af039fe63082",
  "_spec": "async-mutex",
  "_where": "/Users/yaeoni/Desktop/Hub_for_Low_Vision_People/Lvp_Hub",
  "author": {
    "email": "cnspeckn@googlemail.com",
    "name": "Christian Speckner",
    "url": "https://github.com/DirtyHairy/"
  },
  "bugs": {
    "url": "https://github.com/DirtyHairy/async-mutex/issues"
  },
  "bundleDependencies": false,
  "dependencies": {
    "tslib": "^2.0.0"
  },
  "deprecated": false,
  "description": "A mutex for guarding async workflows",
  "devDependencies": {
    "@sinonjs/fake-timers": "^6.0.1",
    "@types/mocha": "^7.0.2",
    "@types/node": "^14.0.13",
    "@types/sinonjs__fake-timers": "^6.0.1",
    "@typescript-eslint/eslint-plugin": "^3.3.0",
    "@typescript-eslint/parser": "^3.3.0",
    "coveralls": "^3.1.0",
    "eslint": "^7.2.0",
    "import-sort-style-eslint": "^6.0.0",
    "mocha": "^8.0.1",
    "nyc": "^15.1.0",
    "prettier": "^2.0.5",
    "prettier-plugin-import-sort": "^0.0.4",
    "rollup": "^2.17.0",
    "ts-node": "^8.10.2",
    "typescript": "^3.9.5"
  },
  "eslintConfig": {
    "extends": [
      "eslint:recommended",
      "plugin:@typescript-eslint/eslint-recommended",
      "plugin:@typescript-eslint/recommended"
    ],
    "parser": "@typescript-eslint/parser",
    "plugins": [
      "@typescript-eslint"
    ],
    "root": true,
    "rules": {
      "@typescript-eslint/no-namespace": "off",
      "eqeqeq": "error",
      "no-async-promise-executor": "off"
    }
  },
  "exports": {
    ".": {
      "default": "./lib/index.js",
      "import": "./index.mjs",
      "require": "./lib/index.js"
    },
    "./package.json": "./package.json"
  },
  "files": [
    "es6",
    "index.mjs",
    "lib"
  ],
  "homepage": "https://github.com/DirtyHairy/async-mutex#readme",
  "importSort": {
    ".js, .jsx, .ts, .tsx": {
      "parser": "typescript",
      "style": "eslint"
    }
  },
  "keywords": [
    "async",
    "mutex"
  ],
  "license": "MIT",
  "main": "lib/index.js",
  "module": "es6/index.js",
  "name": "async-mutex",
  "optionalDependencies": {},
  "prettier": {
    "parser": "typescript",
    "printWidth": 120,
    "singleQuote": true,
    "tabWidth": 4
  },
  "readme": "[![Build Status](https://travis-ci.org/DirtyHairy/async-mutex.svg?branch=master)](https://travis-ci.org/DirtyHairy/async-mutex)\n[![npm version](https://badge.fury.io/js/async-mutex.svg)](https://badge.fury.io/js/async-mutex)\n[![Coverage Status](https://coveralls.io/repos/github/DirtyHairy/async-mutex/badge.svg?branch=master)](https://coveralls.io/github/DirtyHairy/async-mutex?branch=master)\n\n# What is it?\n\nThis package implements primitives for synchronizing asynchronous operations in\nJavascript.\n\n## Mutex\n\nThe term \"mutex\" usually refers to a data structure used to synchronize\nconcurrent processes running on different threads. For example, before accessing\na non-threadsafe resource, a thread will lock the mutex. This is guaranteed\nto block the thread until no other thread holds a lock on the mutex and thus\nenforces exclusive access to the resource. Once the operation is complete, the\nthread releases the lock, allowing other threads to aquire a lock and access the\nresource.\n\nWhile Javascript is strictly single-threaded, the asynchronous nature of its\nexecution model allows for race conditions that require similar synchronization\nprimitives. Consider for example a library communicating with a web worker that\nneeds to exchange several subsequent messages with the worker in order to achieve\na task. As these messages are exchanged in an asynchronous manner, it is perfectly\npossible that the library is called again during this process. Depending on the\nway state is handled during the async process, this will lead to race conditions\nthat are hard to fix and even harder to track down.\n\nThis library solves the problem by applying the concept of mutexes to Javascript.\nLocking the mutex will return a promise that resolves once the mutex becomes\navailable. Once the async process is complete (usually taking multiple\nspins of the event loop), a callback supplied to the caller is called in order\nto release the mutex, allowing the next scheduled worker to execute.\n\n# Semaphore\n\nImagine a situation where you need to control access to several instances of\na shared resource. For example, you might want to distribute images between several\nworker processes that perform transformations, or you might want to create a web\ncrawler that performs a defined number of requests in parallel.\n\nA semaphore is a data structure that is initialized to a positive integer value and that\ncan be locked multiple times.\nAs long as the semaphore value is positive, locking it will return the current value\nand the locking process will continue execution immediately; the semaphore will\nbe decremented upon locking. Releasing the lock will increment the semaphore again.\n\nOnce the semaphore has reached zero, the next process that attempts to acquire a lock\nwill be suspended until another process releases its lock and this increments the semaphore\nagain.\n\nThis library provides a semaphore implementation for Javascript that is similar to the\nmutex implementation described above.\n\n# How to use it?\n\n## Installation\n\nYou can install the library into your project via npm\n\n    npm install async-mutex\n\nThe library is written in TypeScript and will work in any environment that\nsupports ES5, ES6 promises and `Array.isArray`. On ancient browsers,\na shim can be used (e.g. [core-js](https://github.com/zloirock/core-js)).\nNo external typings are required for using this library with\nTypeScript (version >= 2).\n\nStarting with Node 12.16 and 13.7, native ES6 style imports are supported.\n\n**WARNING:** Node 13 versions < 13.2.0 fail to import this package correctly.\nNode 12 and earlier are fine, as are newer versions of Node 13.\n\n## Importing\n\n**CommonJS:**\n```javascript\nvar Mutex = require('async-mutex').Mutex;\nvar Semaphore = require('async-mutex').Semaphore;\nvar withTimeout = require('async-mutex').withTimeout;\n```\n\n**ES6:**\n```javascript\nimport {Mutex, Semaphore, withTimeout} from 'async-mutex';\n```\n\nWith the latest version of Node, native ES6 style imports are supported.\n\n**TypeScript:**\n```typescript\nimport {Mutex, MutexInterface, Semaphore, SemaphoreInterface, withTimeout} from 'async-mutex';\n```\n\n##  Mutex API\n\n### Creating\n\n```typescript\nconst mutex = new Mutex();\n```\n\nCreate a new mutex.\n\n### Locking\n\nPromise style:\n```typescript\nmutex\n    .acquire()\n    .then(function(release) {\n        // ...\n    });\n```\n\nasync/await:\n```typescript\nconst release = await mutex.acquire();\ntry {\n    // ...\n} finally {\n    release();\n}\n```\n\n`acquire` returns an (ES6) promise that will resolve as soon as the mutex is\navailable and ready to be accessed. The promise resolves with a function `release` that\nmust be called once the mutex should be released again.\n\n**IMPORTANT:** Failure to call `release` will hold the mutex locked and will\nlilely deadlock the application. Make sure to call `release` under all circumstances\nand handle exceptions accordingly.\n\n#### Alternate release API\n\nA locked mutex can also be released by calling the `release` method on the mutex. This will\nrelease the current lock on the mutex.\n\n**WARNING:** Using this API comes with the inherent danger of releasing a mutex locked\nin an entirely unrelated place. Use with care.\n\nPromise style:\n```typescript\nmutex\n    .acquire()\n    .then(function() {\n        // ...\n\n        // Please read and understand the WARNING above before using this API.\n        mutex.release();\n    });\n```\n\nasync/await:\n```typescript\nawait mutex.acquire();\ntry {\n    // ...\n} finally {\n    // Please read and understand the WARNING above before using this API.\n    mutex.release();\n}\n```\n\n### Synchronized code execution\n\nPromise style:\n```typescript\nmutex\n    .runExclusive(function() {\n        // ...\n    })\n    .then(function(result) {\n        // ...\n    });\n```\n\nasync/await:\n```typescript\nawait mutex.runExclusive(async () => {\n    // ...\n});\n```\n\n`runExclusive` schedules the supplied callback to be run once the mutex is unlocked.\nThe function may return a promise. Once the promise is resolved or rejected (or immediately after\nexecution if an immediate value was returned),\nthe mutex is released. `runExclusive` returns a promise that adopts the state of the function result.\n\nThe mutex is released and the result rejected if an exception occurs during execution\nif the callback.\n\n### Checking whether the mutex is locked\n\n```typescript\nmutex.isLocked();\n```\n\n##  Semaphore API\n\n### Creating\n\n```typescript\nconst semaphore = new Semaphore(initialValue);\n```\n\nCreates a new semaphore. `initialValue` is a positive integer that defines the\ninitial value of the semaphore (aka the maximum number of concurrent consumers)\n\n### Locking\n\nPromise style:\n```typescript\nsemaphore\n    .acquire()\n    .then(function([value, release]) {\n        // ...\n\n        release();\n    });\n```\n\nasync/await:\n```typescript\nconst [value, release] = await semaphore.acquire();\ntry {\n    // ...\n} finally {\n    release();\n}\n```\n\n`acquire` returns an (ES6) promise that will resolve as soon as the semaphore is\navailable and ready to be accessed. The promise resolves to an array with the\nfirst entry being the current value of the semaphore, and the second value a\nfunction that must be called to release the semaphore once the critical operation\nhas completed.\n\n**IMPORTANT:** Failure to call `release` will hold the semaphore locked and will\nlilely deadlock the application. Make sure to call `release` under all circumstances\nand handle exceptions accordingly.\n\n#### Alternate release API\n\nA locked semaphore can also be released by calling the `release` method on the semaphore.\nThis will release the most recent lock on the semaphore. As such, this will only work with\nsemaphores with `maxValue == 1`. Calling this on other semaphores will throw an exception.\n\n**WARNING:** Using this API comes with the inherent danger of releasing a semaphore locked\nin an entirely unrelated place. Use with care.\n\nPromise style:\n```typescript\nsemaphore\n    .acquire()\n    .then(function([value]) {\n        // ...\n\n        // Please read and understand the WARNING above before using this API.\n        semaphore.release();\n    });\n```\n\nasync/await:\n```typescript\nconst [value] = await semaphore.acquire();\ntry {\n    // ...\n} finally {\n    // Please read and understand the WARNING above before using this API.\n    semaphore.release();\n}\n```\n\n### Synchronized code execution\n\nPromise style:\n```typescript\nsemaphore\n    .runExclusive(function(value) {\n        // ...\n    })\n    .then(function(result) {\n        // ...\n    });\n```\n\nasync/await:\n```typescript\nawait semaphore.runExclusive(async (value) => {\n    // ...\n});\n```\n\n`runExclusive` schedules the supplied callback to be run once the semaphore is available.\nThe callback will receive the current value of the semaphore as its argument.\nThe function may return a promise. Once the promise is resolved or rejected (or immediately after\nexecution if an immediate value was returned),\nthe semaphore is released. `runExclusive` returns a promise that adopts the state of the function result.\n\nThe semaphore is released and the result rejected if an exception occurs during execution\nif the callback.\n\n### Checking whether the semaphore is locked\n\n```typescript\nsemaphore.isLocked();\n```\n\nThe semaphore is considered to be locked if it has a value of zero.\n\n## Limiting the time waiting for a mutex or semaphore to become available\n\nSometimes it is desirable to limit the time a program waits for a mutex or\nsemaphore to become available. The `withTimeout` decorator can be applied\nto both semaphores and mutexes and changes the behavior of `acquire` and\n`runExclusive` accordingly.\n\n```typescript\n    const mutexWithTimeout = withTimeout(new Mutex(), 100, new Error('timeout'));\n    const semaphoreWithTimeout = withTimeout(new Semaphore(5), 100, new Error('timeout'));\n```\n\nThe API of the decorated mutex or semaphore is unchanged.\n\nThe second argument of `withTimeout` is\nthe timout in milliseconds. After the timeout is exceeded, the promsie returned by\n`acquire` and `runExclusive` will reject. The latter will not run the provided callback in\ncase of an timeout.\n\nThe third argument of `withTimeout` is optional and can be used to\ncustomize the error with which the promise is rejected.\n\n# License\n\nFeel free to use this library under the conditions of the MIT license.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/DirtyHairy/async-mutex.git"
  },
  "scripts": {
    "build": "tsc && tsc -p tsconfig.es6.json && tsc -p tsconfig.mjs.json && rollup -o index.mjs mjs/index.js",
    "coveralls": "cat ./coverage/lcov.info | coveralls",
    "lint": "eslint src/**/*.ts test/**/*.ts",
    "prepublish": "yarn test && yarn build",
    "test": "yarn lint && nyc --reporter=text --reporter=html --reporter=lcov mocha test/*.ts"
  },
  "types": "lib/index.d.ts",
  "version": "0.2.4"
}
